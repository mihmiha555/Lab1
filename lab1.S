
#define EXEC_ONLY 0x8           //сегмент кода, только для исполнения
#define EXEC_READ 0xA           //сегмент кода, чтение и исполнение 
#define READ_ONLY 0x0           //сегмент данных, только чтение
#define READ_WRITE 0x2          //сегмент данных, чтение и запись
#define G_BYTE 0x0              //байтовая гранулярность
#define G_PAGE 0x80             //страничная гранулярность
#define SEG_16 0x0              //16-разрядный сегмент
#define SEG_32 0x40             //32-разрядный сегмент

#define STACK_SIZE 0x10         //размер стека

/*************************************************************************************************************
*   Структура селектора сегмента
*
*  15                      3   2  1    0
*  +------------------------+----+-----+
*  |          Index         | TI | RPL |
*  +------------------------+----+-----+
*
*   Структура дескриптора сегмента
*
*  31                     24 23  22  21  20  19         16 15  14 13 12  11        8 7                       0
*  +------------8-----------+-1-+-1-+-1-+-1-+------4------+-1-+--2--+-1-+-----4-----+------------8-----------+
*  |       Base 31:24       | G |D/B| L |AVL|Seg Lim 19:16| P | DPL | S |   Type    |       Base 23:16       | 4
*  +------------------------+---+---+---+---+-------------+---+-----+---+-----------+------------------------+
*  31                                                   16 15                                                0
*  +--------------------------16--------------------------+------------------------16------------------------+
*  |                  Base Address 15:00                  |               Segment Limit 15:00                | 0
*  +------------------------------------------------------+--------------------------------------------------+
*
**/
    
/*****************************************************************************
*   Макроопределение в С-стиле. Создает дескриптор с заданными параметрами
*   base, limit, type. Для задания типа использовать макропределения выше
**/

#define descr(base, limit, type, attr)  \
        .word   (limit & 0xFFFF);       \
        .word   (base & 0xFFFF);            \
        .byte   ((base >> 16) & 0xFF);  \
        .byte   (0x90 | (type));            \
        .byte   (attr | ((limit >> 16) & 0xF)); \
        .byte   ((base >> 24) & 0xFF)

/*****************************************************************************
*   Компоновщик не умеет работать с любой другой моделью памяти, короме FLAT
*   Для прямой адресации использовать следующие макросы
**/

#define CS_OFF(label) (label - _start)
#define DS_OFF(label) (label - .data)

/*****************************************************************************
*   Процессор загружает первый сектор диска (512 байт) по адресу 0x0:0x7C00
*   и передает на него управление: ip = 0x7C00 
*   Процессор находится в реальном режиме 
*
*   Значения сегментных регистров:
*   cs = 0x0    ds = 0x0    es = 0x0
*   ss = 0x0    fs = 0x0    gs = 0x0
*
**/

/*************************************************** Начало секции кода ***************************************************/

    .code16                                             //указание ассемблеру генерировать 16-разрядный код
    .text

.global _start
_start: 
    movw    $0x3, %ax                                   //очистка экрана; задаем режим видеоадаптера (80x25, 16-цветный)
    int     $0x10                                       //используем 0x10 прерывание BIOS (ah = 0, al = 3)

    movw    $.data, %ax
    movw    $seg_data, %bx                              //записываем базовый адрес сегмента данных в соответствующий дескриптор
    movw    %ax, 2(%bx)                             
    movw    $.stack, %ax                                //записываем базовый адрес сегмента стека в соответствующий дескриптор                                      
    movw    $seg_stack, %bx                             
    movw    %ax, 2(%bx)                                 //(для кода и видеобуфера базовые адреса известны)

    cli                                                 //запрещаем аппаратные прерывания
    movb    $0x80, %al
    outb    %al, $0x70                                  //запрещаем NMI (немаскируемые прерывания)

    inb     $0x92, %al                                  //включаем А20 адресную линию
    orb     $0x2, %al
    outb    %al, $0x92

    lgdt    gdtdesc                                     //загружаем значение GDTR

    movl    %cr0, %eax
    orl     $1, %eax
    movl    %eax, %cr0                                  //устанавливаем бит PE в регистре CR0 -----+
                                                        //                                         |--> Эти инструкции должны выполняться 
    ljmp    $0x8, $CS_OFF(goto_prot)                    //переходим в новый сегмент кода (cs, ip)--+    непосредственно друг за другом

/*****************************************************************************
*   Теперь процессор работает в защищенном режиме
**/
    .code32                                             //указание ассемблеру генерировать 32-разрядный код
goto_prot:
    movw    $0x10, %ax
    movw    %ax, %ds                                    //загружаем новый селектор сегмента данных                                  
    movw    $0x18, %ax
    movw    %ax, %ss                                    //загружаем новый селектор сегмента стека
    movl    $STACK_SIZE, %esp                           //устанавливаем указатель стека на значение "дна" стека
    movw    $0x20, %ax
    movw    %ax, %es                                    //загружаем селектор сегмента видеобуфера

/* Протестируем запись символов ascii в видеопамять */

    movl    $320, %ebx                                  //начальное смещение на экране
    movl    $110, %ecx                                  //число выводимых символов
    movw    %ds:DS_OFF(symbol), %ax                     //загружаем начальный символ с атрибутом (обращение к сегменту данных !)
print_pm:
    movw    %ax, %es:(%ebx)                             //записываем очередной символ в видеопамять (обращение к сегменту видеопамяти !)
    addl    $2, %ebx                                    //смещаемся в видеобуфере
    incw    %ax                                         //код следующего символа
    pushl   %ecx                                        //сохраняем ecx в стеке (обращение к сегменту стека !)
    movl    $0x0FFFFF, %ecx                             //добавим паузу для наглядности
idle:
    nop
    loop    idle                                        //цикл паузы
    popl    %ecx                                        //возвращаем ecx из стека
    loop    print_pm                                    //цикл вывода на экран
    
/* Подготовим переход в реальный режим. Сперва надо сформировать дескрипторы для реального режима.
   Для этого модифицируем соответствующие дескрипторы в GDT */

    movw    $0xFFFF, %ds:DS_OFF(seg_text)               //требуется сегмент кода с лимитом 64K 
    movb    $0, %ds:DS_OFF(seg_text) + 6
    orb     $EXEC_READ, %ds:DS_OFF(seg_text) + 5        //и доступный для чтения

    movw    $0xFFFF, %ds:DS_OFF(seg_data)               //Для остальных сегментов требования следующие:
    movb    $0, %ds:DS_OFF(seg_data) + 6                //  Limit = 64K (0xFFFF) 
    orb     $READ_WRITE, %ds:DS_OFF(seg_data) + 5       //  Byte granularity (G = 0)
                                                        //  Expand up (E = 0)
    movw    $0xFFFF, %ds:DS_OFF(seg_stack)              //  Writable (W = 1) 
    movb    $0, %ds:DS_OFF(seg_stack) + 6               //  Present (P = 1)
    orb     $READ_WRITE, %ds:DS_OFF(seg_stack) + 5
           
    movw    $0xFFFF, %ds:DS_OFF(seg_videomem)
    movb    $0, %ds:DS_OFF(seg_videomem) + 6
    orb     $READ_WRITE, %ds:DS_OFF(seg_videomem) + 5
    
    movw    $0x10, %ax                                  //загрузим теневые регистры сегментов
    movw    %ax, %ds
    movw    $0x18, %ax
    movw    %ax, %ss
    movw    $0x20, %ax
    movw    %ax, %es

    ljmp    $0x8, $CS_OFF(goto_64k_segment)             //выполним дальний переход чтобы снова загрузить селектор
                                                        //в CS и модифицировать его теневой регистр
goto_64k_segment:

    .code16                                             //снова генерируем 16-разрядный код
    movl    %cr0, %eax
    andl    $0xFFFFFFFE, %eax
    movl    %eax, %cr0                                  //Сбросим бит PE в регистре CR0 

    ljmp    $0x7C0, $CS_OFF(goto_real)                  //переходим в реальный режим

/*****************************************************************************
*   Теперь процессор снова работает в реальном режиме
*/

goto_real:
    movw    $.data, %ax                                 //возвращаем значения сегментных регистров реального режима
    shrw    $4, %ax
    movw    %ax, %ds
    movw    %ax, %es 
    movw    $.stack, %ax
    shrw    $4, %ax
    movw    %ax, %ss

    sti                                                 //разрешим аппаратные и немаскируемые прерывания
    movb    $0, %al
    outb    %al, $0x70

/* Проверим работоспособность сервиса BIOS */

    movb    $0x0E, %ah                                  //вывод символа в режиме телетайпа (атрибут текущий)
    xorw    %bx, %bx                                    //0-ая страница видеопамяти

    movw    $DS_OFF(mesg), %si                          //смещение строки символов в регистр si

print_rm:
    movb    (%si), %al
    cmpb    $0, %al                                     //пока не встретился '\0'
    je      hang
    inc     %si 
    int     $0x10                                       //выводим символы строки на экран
    loop    print_rm   

hang:
    jmp     hang                                        //зацикливание

text_size = . - _start                                  //размер секции кода


/************************************************Начало секции данных******************************************************/
    .data 

/*--------------------------------------------------------------------------------------------------------------------------
*   Глобальная таблица дескрипторов
*/                                                    
    .align  16                                          //процессор быстрее обращается с выровненной таблицей
GDT:
seg_null:       .quad   0                                                       //нулевой дескриптор
seg_text:       descr   (0x7C00, (text_size -1), EXEC_READ, G_BYTE | SEG_32)    //дескриптор сегмента кода   (селектор 0x8 )
seg_data:       descr   (0, (data_size - 1), READ_WRITE, G_BYTE | SEG_32)       //дескриптор сегмента данных (селектор 0x10)
seg_stack:      descr   (0, (stack_size - 1), READ_WRITE, G_BYTE | SEG_32)      //дескриптор сегмента стека  (селектор 0x18)
seg_videomem:   descr   (0xB8000, 0xFFF, READ_WRITE, G_BYTE | SEG_32)           //дескриптор видеобуфера     (селектор 0x20)
GDT_size = . - GDT

/*------------------------------------------------------------------------------------------------------------------------*/

gdtdesc:    .word   GDT_size - 1    //предел GDT                
            .long   GDT             //базовый адрес GDT

symbol:     .byte   1               //начальный код символа для вывода на экран в защищенном режиме
sym_attr:   .byte   0x1e            //атрибут символа

mesg:       .asciz  "Back to real mode!!!"  //сообщение при возвращении в реальный режим

data_size = . - .data               //размер секции данных

/**************************************************** Секция стека *********************************************************/

    .section    .stack, "wa"
    .align 16

    .space  STACK_SIZE, '^'         //выделим место под стек и заполним его символом '^'
                
stack_size = . - .stack             //размер секции стека

/***************************************************************************************************************************/ 

